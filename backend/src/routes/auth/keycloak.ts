import type { FastifyRequest, FastifyReply } from 'fastify';
import { db } from '@/database/connection.js';
import { exchangeCodeForTokens } from '@/keycloak/config.js';

/**
 * Keycloak authentication callback handler
 * Handles OAuth2 callback from Keycloak after successful authentication
 */
export async function keycloakCallbackHandler(
  request: FastifyRequest<{
    Querystring: { code: string; state?: string };
  }>,
  reply: FastifyReply
) {
  const { code } = request.query;

  if (!code) {
    return reply.status(400).send({
      error: 'Bad Request',
      message: 'Authorization code is required',
    });
  }

  try {
    // Exchange authorization code for tokens
    const tokens = await exchangeCodeForTokens(
      code,
      'http://localhost:3001/api/auth/keycloak/callback'
    );

    // Get user info from Keycloak
    const userInfoResponse = await fetch(
      `${process.env.KEYCLOAK_URL || 'http://localhost:8080'}/realms/${process.env.KEYCLOAK_REALM || 'realchat'}/protocol/openid-connect/userinfo`,
      {
        headers: { Authorization: `Bearer ${tokens.access_token}` },
      }
    );

    const userInfo = await userInfoResponse.json();

    // Check if user exists in database
    const existingUser = await db.query(
      'SELECT * FROM users WHERE keycloak_id = $1',
      [userInfo.sub]
    );

    let user;

    if (existingUser.rows.length === 0) {
      // Create new user from Keycloak info
      const result = await db.query(
        `INSERT INTO users (
          keycloak_id, username, email, email_verified,
          first_name, last_name, public_id, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
        RETURNING id, username, public_id, email, keycloak_id`,
        [
          userInfo.sub,
          userInfo.preferred_username || userInfo.username,
          userInfo.email || null,
          userInfo.email_verified || false,
          userInfo.given_name || null,
          userInfo.family_name || null,
          null, // Public ID will be generated by trigger if exists
        ]
      );

      user = result.rows[0];
    } else {
      // Update existing user with latest Keycloak info
      const result = await db.query(
        `UPDATE users SET
          email = $1,
          email_verified = $2,
          first_name = $3,
          last_name = $4
        WHERE id = $5
        RETURNING id, username, public_id, email, keycloak_id`,
        [
          userInfo.email || existingUser.rows[0].email,
          userInfo.email_verified || existingUser.rows[0].email_verified,
          userInfo.given_name || existingUser.rows[0].first_name,
          userInfo.family_name || existingUser.rows[0].last_name,
          existingUser.rows[0].id,
        ]
      );

      user = result.rows[0];
    }

    // Return tokens and user info
    return reply.status(200).send({
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
      expires_in: tokens.expires_in,
      refresh_expires_in: tokens.refresh_expires_in,
      user: {
        userId: user.id,
        username: user.username,
        publicId: user.public_id,
        email: user.email,
        keycloakId: user.keycloak_id,
      },
    });
  } catch (error) {
    console.error('Keycloak callback error:', error);
    return reply.status(500).send({
      error: 'Internal Server Error',
      message: 'Authentication failed',
    });
  }
}

/**
 * Refresh token handler
 */
export async function keycloakRefreshHandler(
  request: FastifyRequest<{
    Body: { refresh_token: string };
  }>,
  reply: FastifyReply
) {
  const { refresh_token } = request.body;

  if (!refresh_token) {
    return reply.status(400).send({
      error: 'Bad Request',
      message: 'Refresh token is required',
    });
  }

  try {
    const { refreshAccessToken } = await import('@/keycloak/config.js');
    const tokens = await refreshAccessToken(refresh_token);

    return reply.status(200).send({
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
      expires_in: tokens.expires_in,
      refresh_expires_in: tokens.refresh_expires_in,
    });
  } catch (error) {
    console.error('Keycloak refresh error:', error);
    return reply.status(401).send({
      error: 'Unauthorized',
      message: 'Invalid or expired refresh token',
    });
  }
}

/**
 * Logout handler
 */
export async function keycloakLogoutHandler(
  request: FastifyRequest<{
    Body: { refresh_token: string };
  }>,
  reply: FastifyReply
) {
  const { refresh_token } = request.body;

  if (!refresh_token) {
    return reply.status(400).send({
      error: 'Bad Request',
      message: 'Refresh token is required',
    });
  }

  try {
    const { logoutFromKeycloak } = await import('@/keycloak/config.js');
    await logoutFromKeycloak(refresh_token);

    return reply.status(200).send({
      message: 'Logged out successfully',
    });
  } catch (error) {
    console.error('Keycloak logout error:', error);
    // Don't fail on logout error, just log it
    return reply.status(200).send({
      message: 'Logged out successfully',
    });
  }
}
