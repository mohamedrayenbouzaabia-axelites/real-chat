import type { FastifyRequest, FastifyReply } from 'fastify';
import { db } from '@/database/connection.js';
import { passwordService } from '@/lib/auth/password.js';
import { jwtService } from '@/lib/auth/jwt.js';
import { publicIdService } from '@/lib/identity/publicId.js';
import { registerSchema, type RegisterInput } from '@/schemas/auth.js';
import { validateBody } from '@/middleware/validation.js';

/**
 * User registration handler
 */
export async function registerHandler(
  request: FastifyRequest,
  reply: FastifyReply
) {
  // Validate input
  const validation = await validateBody(registerSchema)(request, reply);
  if (!validation) {
    return; // Validation error already sent
  }

  const body = request.body as RegisterInput;

  try {
    // Check if username already exists
    const existingUsername = await db.query(
      'SELECT id FROM users WHERE username = $1',
      [body.username]
    );

    if (existingUsername.rowCount > 0) {
      return reply.status(409).send({
        error: 'Conflict',
        message: 'Username already taken',
      });
    }

    // Check if email already exists
    const existingEmail = await db.query(
      'SELECT id FROM users WHERE email = $1',
      [body.email]
    );

    if (existingEmail.rowCount > 0) {
      return reply.status(409).send({
        error: 'Conflict',
        message: 'Email already registered',
      });
    }

    // Hash password
    const passwordHash = await passwordService.hash(body.password);

    // Generate unique public ID
    const publicId = await publicIdService.generateUnique();

    // Generate identity keys (if not provided by client)
    // For now, we'll generate placeholder keys
    // In production, these should be generated by the client
    const identityKeyPublic = body.identityKeyPublic || 'placeholder-public-key';
    const identityKeyPrivateEncrypted = 'placeholder-encrypted-private-key';
    const signedPreKeyPublic = body.signedPreKeyPublic || 'placeholder-signed-pre-key';
    const signedPreKeySignature = body.signedPreKeySignature || 'placeholder-signature';
    const signedPreKeyPrivateEncrypted = 'placeholder-encrypted-signed-pre-key';

    // Create user
    const result = await db.query(
      `INSERT INTO users (
        username,
        email,
        password_hash,
        public_id,
        identity_key_public,
        identity_key_private_encrypted,
        signed_pre_key_public,
        signed_pre_key_signature,
        signed_pre_key_private_encrypted
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id, username, email, public_id, email_verified, first_name, last_name, created_at`,
      [
        body.username,
        body.email,
        passwordHash,
        publicId,
        identityKeyPublic,
        identityKeyPrivateEncrypted,
        signedPreKeyPublic,
        signedPreKeySignature,
        signedPreKeyPrivateEncrypted,
      ]
    );

    const user = result.rows[0];

    // Generate tokens
    const tokens = jwtService.generateTokenPair({
      userId: user.id,
      username: user.username,
    });

    // Return user data and tokens
    return reply.status(201).send({
      user: {
        id: user.id,
        userId: user.id,
        username: user.username,
        email: user.email,
        emailVerified: user.email_verified,
        firstName: user.first_name,
        lastName: user.last_name,
        publicId: user.public_id,
        createdAt: user.created_at,
      },
      tokens: {
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
      },
    });
  } catch (error) {
    console.error('Registration error:', error);
    return reply.status(500).send({
      error: 'Internal server error',
      message: 'Failed to create user',
    });
  }
}
